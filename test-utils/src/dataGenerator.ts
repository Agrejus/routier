import { CompiledSchema, InferCreateType, SchemaTypes } from "@routier/core";
import { PropertyInfo } from "@routier/core";
import { faker } from '@faker-js/faker';

// Helper function to generate random data based on property type
function generateValueForProperty(property: PropertyInfo<any>): any {
    // Skip identity properties as they will be generated by the data store
    if (property.isIdentity) {
        return undefined;
    }

    // Handle default values if they exist
    if (property.defaultValue != null) {
        if (typeof property.defaultValue === 'function') {
            return property.defaultValue(property.injected);
        }
        return property.defaultValue;
    }

    // Check for literals first
    if (property.literals && property.literals.length > 0) {
        return faker.helpers.arrayElement(property.literals);
    }

    // Generate random data based on property type using Faker
    switch (property.type) {
        case SchemaTypes.String:
            // Use different faker methods based on property name for more realistic data
            const name = property.name.toLowerCase();
            if (name.includes('name')) {
                return faker.person.fullName();
            } else if (name.includes('email')) {
                return faker.internet.email();
            } else if (name.includes('phone')) {
                return faker.phone.number();
            } else if (name.includes('address')) {
                return faker.location.streetAddress();
            } else if (name.includes('city')) {
                return faker.location.city();
            } else if (name.includes('state')) {
                return faker.location.state();
            } else if (name.includes('zip') || name.includes('postal')) {
                return faker.location.zipCode();
            } else if (name.includes('country')) {
                return faker.location.country();
            } else if (name.includes('company')) {
                return faker.company.name();
            } else if (name.includes('job')) {
                return faker.person.jobTitle();
            } else if (name.includes('url')) {
                return faker.internet.url();
            } else if (name.includes('username')) {
                return faker.internet.userName();
            } else if (name.includes('password')) {
                return faker.internet.password();
            } else if (name.includes('description')) {
                return faker.lorem.paragraph();
            } else if (name.includes('title')) {
                return faker.lorem.sentence();
            } else if (name.includes('text')) {
                return faker.lorem.text();
            } else {
                return faker.lorem.word();
            }
        case SchemaTypes.Number:
            return faker.number.int({ min: 0, max: 1000 });
        case SchemaTypes.Boolean:
            return faker.datatype.boolean();
        case SchemaTypes.Date:
            return faker.date.recent();
        case SchemaTypes.Object:
            return generateObject(property);
        case SchemaTypes.Array:
            return generateArray(property);
        case SchemaTypes.Function:
        case SchemaTypes.Computed:
            // Skip functions and computed properties
            return undefined;
        default:
            return null;
    }
}

// Generate data for an object type property
function generateObject(property: PropertyInfo<any>): any {
    const result: any = {};

    // Recursively generate data for each child property
    for (const child of property.children) {
        const value = generateValueForProperty(child);
        if (value !== undefined) {
            result[child.name] = value;
        }
    }

    return result;
}

// Generate data for an array type property
function generateArray(property: PropertyInfo<any>): any[] {
    // Generate 1-5 random items for the array
    const length = faker.number.int({ min: 1, max: 5 });
    const result: any[] = [];

    // If we have literals, use those for array items
    if (property.literals && property.literals.length > 0) {
        for (let i = 0; i < length; i++) {
            result.push(faker.helpers.arrayElement(property.literals));
        }
        return result;
    }

    // Get the array item type from innerSchema
    const arrayItemType = property.innerSchema;

    // Generate items based on the array item type
    if (arrayItemType) {
        for (let i = 0; i < length; i++) {
            const value = generateValueForProperty(new PropertyInfo(arrayItemType, 'item', property));
            if (value !== undefined) {
                result.push(value);
            }
        }
    }

    return result;
}

export const generateData = <T extends {}>(schema: CompiledSchema<T>, count: number): InferCreateType<T>[] => {

    const result: InferCreateType<T>[] = [];

    // Generate the specified number of items
    for (let i = 0; i < count; i++) {
        const item: any = {};

        // Generate data for each property in the schema
        for (const property of schema.properties) {

            if (property.isIdentity === true) {
                continue;
            }

            const value = generateValueForProperty(property);
            if (value !== undefined) {
                item[property.name] = value;
            }
        }

        result.push(item as InferCreateType<T>);
    }

    return result;
};